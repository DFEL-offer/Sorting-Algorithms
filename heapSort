/*
一. 堆排序的核心思想
堆排序是一种基于堆数据结构的排序算法，其核心思想如下：
    1.建堆（Heapify）：
        -将待排序的数组构建成一个堆（通常为最大堆或最小堆）。在最大堆中，堆顶元素是整个数组的最大值。
    2.排序（Sort）：
        -将堆顶元素（当前最大值）与数组末尾元素交换，然后从堆顶开始调整剩余元素，使其重新满足堆的性质。
        -重复这个过程，直到所有元素都已排序。
二.时间复杂度
    1.最坏情况：O(n log n)
        -每次调整堆的复杂度为O(logn)，需要调整 n 次。
    2.最好情况：O(n log n)
        -即使输入数据已经有序，堆排序仍然需要构建堆和调整堆，时间复杂度保持为O(n log n)。
    3.平均情况：O(n log n)
        -堆排序的平均时间复杂度也为 O(n log n)，因为每次调整堆的复杂度稳定。
三.空间复杂度
    1.空间复杂度为 O(1)
        -堆排序是原地排序算法，不需要额外的辅助数组，仅利用数组本身完成排序。
四.优点
    1.原地排序：
        -堆排序在数组上原地构建堆，不需要额外空间。
    2.时间复杂度稳定：
        -无论输入数据的初始顺序如何，时间复杂度始终为O(n log n)，表现稳定。
    3.适合动态数据:
        -堆是一种高效的优先队列实现，堆排序直接基于这一特性。
    4.不依赖输入数据分布:
        -无论输入是随机分布、有序或部分有序，堆排序的性能都一致。
五.缺点
    1.不稳定：
        -堆排序无法保持相同元素的相对顺序，因此不是稳定排序。
    2.缓存不友好：
        -堆调整过程中存在大量的非连续内存访问，对 CPU 缓存的利用率较低。
    3.实现较复杂:
        -与归并排序、快速排序相比，堆排序的实现需要更多细节处理。
六.适用场景
    1.内存有限的场景:
        -由于堆排序是原地排序，空间复杂度为O(1)，适合内存紧张的场景。
    2.需要时间复杂度稳定：
        -在要求稳定性能的环境中，堆排序的时间复杂度始终为O(n log n)。
    3.优先队列应用：
        -堆排序直接基于堆数据结构，适合与优先队列相关的任务。
七.优化策略
    1.优化建堆过程：
        -从最后一个非叶子节点开始调整堆，减少不必要的调整操作。
        -使用原地归并：虽然较为复杂，但可以尝试实现原地归并，以降低空间复杂度。
    2.非递归实现:
        -使用迭代方式实现堆调整，避免递归调用带来的栈空间开销。
    3.缓存优化：
        -调整数组访问顺序，尽量增加对相邻内存的访问，提高缓存命中率。
    4.小规模优化：
        -对于较小的数组，可以结合插入排序，在堆排序的最后阶段提升性能。
*/

#include <iostream>
using namespace std;

const int N = 1e5 + 10; // 数组最大容量
int a[N], n; // 输入数组和元素个数

// 向下调整堆的函数
void down(int parent, int len) {
    int child = parent * 2; // 左子节点
    while (child <= len) {
        // 如果右子节点存在，且大于左子节点，则选择右子节点
        if (child + 1 <= len && a[child + 1] > a[child]) child++;

        // 如果父节点已经大于等于最大的子节点，直接返回
        if (a[parent] >= a[child]) return;

        // 否则交换父节点和子节点
        swap(a[parent], a[child]);

        // 更新父节点和子节点索引
        parent = child;
        child = parent * 2;
    }
}

// 堆排序主函数
void heapSort() {
    // 1. 建堆：从最后一个非叶子节点开始调整堆
    for (int i = n / 2; i >= 1; --i) {
        down(i, n);
    }

    // 2. 排序：逐步将堆顶元素（最大值）移动到数组末尾
    for (int i = n; i > 1; --i) {
        swap(a[1], a[i]); // 将堆顶元素交换到末尾
        down(1, i - 1);   // 调整剩余的堆
    }
}

// 主函数
int main() {
    // 输入数据
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }

    // 堆排序
    heapSort();

    // 输出结果
    for (int i = 1; i <= n; ++i) {
        cout << a[i] << " ";
    }
    return 0;
}
