/*
一. 归并排序的核心思想
归并排序是一种分治法（Divide and Conquer）的排序算法，其核心思想包括以下几个步骤：
    1.分割（Divide）：
        -将待排序的数组递归地分割成两半，直到每个子数组只包含一个元素（自然有序）。
    2.合并（Conquer）：
        -在合并过程中，比较两个子数组的元素，将较小的元素放入临时数组，最终形成一个有序的数组。
    3.递归排序:
        -对每一半子数组递归地应用分割和合并步骤，直到整个数组有序。
二.时间复杂度
    1.最坏情况：O(n log n)
        -无论输入数据的初始状态如何，归并排序总是将数组分割成两半并进行合并，时间复杂度为O(n log n)。
    2.最好情况：O(n log n)
        -即使数组已经是有序的，归并排序仍然需要进行分割和合并操作，时间复杂度保持为O(n log n)。
    3.平均情况：O(n log n)
        -平均情况：O(n log n)
三.空间复杂度
    1.空间复杂度为 O(n)
        -归并排序需要额外的临时数组来存储合并过程中产生的子数组。
        -由于需要分配与原数组大小相同的额外空间，因此空间复杂度为线性级别的O(n)。
四.优点
    1.稳定性好：
        -归并排序是稳定排序，能保持相同元素的相对位置不变。
    2.时间复杂度稳定：
        -无论输入数据如何分布，归并排序的时间复杂度始终为O(n log n)，表现稳定。
    3.适用大规模数据:
        -归并排序在处理大规模数据时表现出色，尤其适合外部排序（如磁盘排序）。
    4.适合链表排序:
        -归并排序可以高效地应用于链表，不需要随机访问元素，且空间利用更优。
    5.溢出风险低:
        -因为这个归并排序经过优化,主函数动态分配到堆上,只递归的话基本不可能溢出。
五.缺点
    1.需要额外的存储空间：
        -归并排序需要额外的O(n)空间，这在内存受限的情况下可能成为问题。
    2.非原地排序：
        -由于需要额外的临时数组，归并排序不是原地排序算法，不适用于对空间有严格要求的场景。
    3.对小规模数据效率不如简单算法:
        -对于较小的数据集，归并排序的性能可能不如插入排序等简单且常数因子更小的算法。
六.适用场景
    1.大规模数据集的排序:
        -当需要排序的数据量非常大时，归并排序表现优异，尤其适用于外部排序。
    2.需要稳定排序的场景:
        -在需要保持相同元素相对位置的应用中，归并排序是理想选择。
    3.链表排序：
        -由于归并排序不需要随机访问元素，非常适合用于链表的排序。
    4.需要分布式排序:
        -归并排序的分治特性使其适用于并行和分布式环境中的排序任务。
七.优化策略
    1.优化合并过程：
        -减少内存复制：在合并过程中，尽量减少不必要的内存复制操作，提高缓存命中率。
        -使用原地归并：虽然较为复杂，但可以尝试实现原地归并，以降低空间复杂度。
    2.非递归实现:
        -使用迭代方法代替递归，实现归并排序的分割和合并过程，避免递归带来的栈溢出风险。
    3.小规模子数组使用插入排序：
        -当子数组的规模较小时（例如，长度 ≤ 10），使用插入排序代替递归的归并排序，提高效率。
    4.多线程并行处理：
        -利用多线程对不同的子数组进行并行排序和合并，提升排序的整体速度。
    5.减少临时数组的使用：
        -尽量复用临时数组，避免频繁的内存分配和释放，减少内存管理的开销。
    6.内存访问优化：
        -优化内存访问模式，提高缓存的利用率，减少缓存未命中的次数。
//虽然有这么多的优化策略,但实际上注释下面的代码优化已经属于很好的了
*/
#include <stdio.h>
#include <stdlib.h>
// 函数声明
void merge(int arr[], int temp[], int left, int mid, int right);// 合并两个子数组的函数
void mergeSort(int arr[], int temp[], int left, int right);// 归并排序的递归函数
void printArray(int arr[], int n);// 打印数组的函数（仅打印前100个元素）

int main() {
    int n = 1000000; // 定义数组的大小为1,000,000,为了用大量元素测试排序速度
    // 动态分配内存给原始数组和临时数组
    int* arr = (int*)malloc(sizeof(int) * n);
    int* temp = (int*)malloc(sizeof(int) * n);
    // 检查内存是否分配成功
    if (arr == NULL || temp == NULL) {
        printf("内存分配失败\n");
        return -1; // 返回错误代码
    }
    // 初始化数组，填充随机数
    for (int i = 0; i < n; i++) {
        arr[i] = rand() % 1000000; // 生成0到999,999之间的随机数
    }
    // 调用归并排序函数，对数组进行排序
    mergeSort(arr, temp, 0, n - 1);
    
    printf("排序完成\n"); // 输出排序完成的提示
    
    // 打印排序后的数组（仅打印前100个元素）
    printArray(arr, n);
    
    // 释放动态分配的内存
    free(arr);
    free(temp);
    
    return 0; // 程序正常结束
}
// 合并两个子数组的函数
void merge(int arr[], int temp[], int left, int mid, int right) {
    int i = left;      // 左子数组的起始索引
    int j = mid + 1;   // 右子数组的起始索引
    int k = left;      // 临时数组的起始索引
    
    // 比较左右子数组的元素，将较小的元素复制到临时数组
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j])
            temp[k++] = arr[i++]; // 将左子数组的元素放入临时数组
        else
            temp[k++] = arr[j++]; // 将右子数组的元素放入临时数组
    }
    // 将左子数组剩余的元素复制到临时数组
    while (i <= mid)
        temp[k++] = arr[i++];
    // 将右子数组剩余的元素复制到临时数组
    while (j <= right)
        temp[k++] = arr[j++];
    // 将临时数组中的排序好的元素复制回原数组
    for (int index = left; index <= right; index++) {
        arr[index] = temp[index];
    }
}
// 归并排序的递归函数
void mergeSort(int arr[], int temp[], int left, int right) {
    if (left < right) { // 如果数组中至少有两个元素
        int mid = left + (right - left) / 2; // 找到中间点，防止溢出
        // 递归排序左半部分
        mergeSort(arr, temp, left, mid);
        // 递归排序右半部分
        mergeSort(arr, temp, mid + 1, right);
        // 合并排序后的两个子数组
        merge(arr, temp, left, mid, right);
    }
}

// 打印数组的函数（仅打印前100个元素）
void printArray(int arr[], int n) {
    int limit = n < 100 ? n : 100; // 如果n小于100，打印全部；否则，打印前100个
    for (int i = 0; i < limit; i++) {
        printf("%d ", arr[i]); // 打印数组的每个元素
    }
    if (n > 100) {
        printf("..."); // 省略号表示后续元素未打印
    }
    printf("\n"); // 换行
}
